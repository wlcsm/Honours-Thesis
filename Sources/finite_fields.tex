% My study of Basis mostly came from https://arxiv.org/ftp/arxiv/papers/1304/1304.0420.pdf
\chapter{Finite Fields}\label{finite-fields}

In this section we will look and performing polynomial multiplication where the coefficients are in a finite field and the polynomial is perhaps in a quotient ring.\\

Common reasons to use a finite field:
\begin{itemize}
\item You are doing arbitrary work in one. Thus $p^n$ can be anything and we need to be as generic as possible
\item You are using it to control the error that would arise if you used a complex FFT instead. In this case we perform the calculation over several finite fields and use the Chinese Remainder Theorem to reconstruct the final result. This allows us to have some control over the primes that we choose. (It is actually quite common to use integer rings as well as prime fields).
\item You just need a finite field, such as the Ring Learning with Errors problems. This gives us the most flexibility over the choice of prime field and so we can choose ones which are very efficient to perform arithmetic in using a computer.
\end{itemize}

It is important to differentiate the use cases as each imposes a different set of restriction on the finite fields we can use. The most favourable to implement are of course, those where arithmetic is easily implemented in. This correlates to field fields whose characteristic's binary representation has few ones or that admit very nice optimal normal bases (I haven't covered normal bases yet though).

Remember that one can still use the Karatsuba/Toom-Cook algorithm here as well.

In this section we will cover the Number Theoretic Transform (NTT) which is a generalisation of the Fast Fourier Transform for integer rings. 
% There are several representations of finite fields which affect their efficacy in programs
% \begin{itemize}
% \item Vector spaces: So a representations by a basis
% \item As a cyclotomic ring: So as $g^i \cup \{0\}$ where $g$ is the generator for the multiplicative group of $GF(p^n)$
% \item As a quotient ring: $GF(p)[X] / \phi(X)$ where $\phi(X)$ is an irreducible polynomial of degree $n$.
% \end{itemize}
% Each has their advantages when it comes to addition, multiplication, and other things like logarithms


\section{Number Theoretic Transform}
\label{sec:ntt}

Say we want to take the DFT of a sequence of coefficients of length $m$ in an integer ring $\Z/N$.

In this we look at the Fast Fourier Transform analogue for integer rings. From our previous explanation of the FFT, we showed that the algorithm is based around the existence of roots of unity. Hence we simply must find such a root in a given finite field.

For such an element $\alpha \in \Z/N$ to be a root of unity of order $m$ it must divide $N - 1$ (the order of the multiplicative group of $\Z/N$) and $\alpha^{N/p} \neq 1$ for all $p | N$. We also need $N$ to be invertible and so $N$ and $n$ should be coprime. This can be summarised in the theorem below

\begin{theorem}
  An $N^\th$ root of unity exists in $GF(F)$ if and only if $N$ divides $\gcd(p_1 - 1, \ldots, p_n - 1)$.
\end{theorem}


\subsection{Rader Transform}
\label{subsec:rt}



Suppose that $N$ is prime, then there exists a primitive element for $GF^\times(N)$, that is, a $g \in GF(N)$ such that $\{g^i\}_{i=1}^{N-1}$ generates is a permutation of $1, \ldots, N-1$. Then we consider the DFT under this permutation
\begin{align*}
  A_k - a_0 = \sum^{n-1}_{i=1} a_i \omega_N^{ik} \qquad &\mapsto \qquad A_{g^k} - a_0 = \sum^{n-1}_{i=1} a_{g^i}\omega_n^{g^{i+k}}\\
  \tx{ via } i \mapsto g^i&, k \mapsto g^k
\end{align*}
This can then be realised as the convolution of the two sequences $\{a_{g^i}\}_{i=1}^{n-1}$ and $\omega_N^{g^i}$. Thus from Stockham the sum can be calculated as
\[
  \sum^{n-1}_{i=1} a_{g^i}\omega_n^{g^{i+k}} = \tx{DFT}^{-1}\{\tx{DFT}\{a_{g^{-i}}\}\cdot \tx{DFT}\{\omega_N^{g^i}\}
\]
% Stockham-DFT-for-Convolutions
Hence this is good if $N - 1$ is highly composite because then we can apply normal FFT algorithms.

From this we can then see that our ideal case is where $N = 2^n + 1$ for some $n$ and where $N$ is prime. This leads us to our use of Fermat numbers in the next section.

\section{Use case: Z to Fp}\label{sec:Z-Fp}

In this case we are usually interested in controlling the error that would arise if we used complex values. 

But if the numbers are large then this will cause a precision error, some paper said that its about $n / 2$ bits of precision lost for a $2^n$ transform. So we want to perform the DFT over Z, then what we can do is put it into a bunch of $GF(p)$'s and then go back using the Chinese Remainder Theorem. 

In order for the CRT to work, we need

\begin{itemize}
\item $M > 2nB^2$ where all the coefficients of the input polynomials are bounded by $B$. $nB^2$ is a bound for the absolute size of the resulting coefficients, and then the 2 is there to take into account negative coefficients.
\item A set of distinct primes $p_i$ s.t. $M = \prod_i p_i$
\end{itemize}

This is true because the modulo operator is a group homomorphism


From\footnote{A. Fog. Instruction tables: lists of instruction latencies, throughputs and micro- operation breakdowns for intel, AMD and VIA CPUs, 2017. http://www.agner. org/optimize/} we can see that in general, divisions are not optimised in common CPU's and are thus an expensive operation, operating proportional to the length of the operands. To remedy this in a CPU, we can use Montgomery multiplication\footnote{P. Montgomery. Modular multiplication without trial division. Mathematics of Computation, 44(170):519–521, 1985.} which exchanges division by an arbitrary integer, with division by another integer of our choice. Naturally in a computer we can choose a power of two and so the division is then done in one clock cycle.


\subsection{Fermat Transforms}
\label{subsec:fermat-transforms}

We now look at finding a suitable $N$ such that the NTT in $GF(N)$ can be performed efficiently. As outlined\footnote{Intro to FMT} we can have three simple criteria
\begin{itemize}
\item The transform length $T$, is highly composite to facilitate FFT-like algorithms.
\item Multiplication by the roots of unity are efficient to implement. This corresponds to having a small number of ones in the binary representation
\item Dividing by $N$ is efficient. Also corresponds to a small number of ones in the binary representation.
\end{itemize}

Looking at the last requirement, if we were to take $N$ to be a power of two, then by the previous theorem, the maximum transform length would be $1$, so that isn't good. The next would be to consider $2^k - 1$ for some $k$\footnote{This doesn't have a small number of ones in its binary representation, but it would still be somewhat efficient to implement}. This is known as a Mersenne number and transforms with this modulus are known as Mersenne Number Transforms. The next is $2^k + 1$, it can then be shown that when $k$ itself is a power of two, it has less small divisors. e.g. if $k$ is odd then $3$ divides $2^k + 1$ hence the maximum transform length is $2$. Numbers of the form $2^{2^\ell} + 1$ are known as Fermat Numbers and their corresponding transforms are Fermat Number Transforms (FMT).\\

In fact the Fermat Numbers up to $\ell = 4$ are all primes and so they can be calculated very efficiently using the Rader Transform.
It is then shown in a paper that all the facts of the fermat numbers $2^{2^\ell} + 1$ are of the form $K2^{\ell + 2} + 1$. Therefore the maximum transform length is $2^{\ell + 2}$. A root of such order is $2^{2^{t-2}}(2^{2^{t-1}} - 1)$.\\

Though a downside with this representation is that it requires the representation of $2^k + 1$ bits, so in a computer we would need $2^{k+1}$ bits to represent it. This is therefore not ideal in terms of memory efficiency. Some authors suggest just forgetting about it and rounding a $-1$ to $0$ or $-2$ because there is a low probability $2^{-k}$ chance that the number will arise, though that was in signal processing so I think it probably has a higher chance of showing up in our use cases.\\


\section{Normal Bases}
They are used to make calcuations faster, there are both hardware and software designs that arise from normal bases.

Definition from the Normal bases thesis.
A normal basis of $\F_{q^n}$ over $\F_q$ is thus of the form: $\{\alpha,\alpha^q,\ldots ,\alpha^{q^{n−1}}\}$ for some $\alpha ∈ \F_{q^n}$.

\section{Asymptotic Bounds}

The fabled $O(n \log n)$ bounds for multiplication.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
